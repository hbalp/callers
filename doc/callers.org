#+AUTHOR Hugues Balp
#+TITLE The Callers plug-in
#+COPYRIGHT @ THALES Communications & Security 2012 to 2015

* TODO The Callers plug-in [2/7]				    :callers:
  :PROPERTIES:
  :author:   Hugues Balp
  :partner:  Thales Communications & Security
  :version:  0.1
  :END:
** Header
   #+BEGIN_SRC org :tangle callers.chap6.tcs.D4.2.2.gen.org
#+AUTHOR Hugues Balp
#+TITLE The Callers plug-in
The Callers plug-in
   #+END_SRC
** DONE Introduction/Executive Summary [1/1]
   - [X] Introduce the plugin
   #+BEGIN_SRC org :tangle callers.chap6.tcs.D4.2.2.gen.org
   Callers is a static analysis plugin extending the clang/LLVM compilation framework for enabling early syntactic-based security analysis on large-scale C/C++ software.
   The principle motivation for such a plugin is to satisfy some of the security analysis needs of the Thales Single Sign-On use case (in frame of tasks T5.4 & T5.5).
   #+END_SRC
** DONE Aims [1/1]
   - [X] Describe the objectives of the plug-in and its relation with the security analysis of source code (what security properties are analysed)   
   #+BEGIN_SRC org :tangle callers.chap6.tcs.D4.2.2.gen.org
* Aim
   The main goal of the Callers plugin is to enable early security risks assessments based on the analysis of function calls dependencies.

   For example, if some vulnerabilities are found by source code analysis in the implementation of some particular function,
   the generation of a callgraph of all the possible callers of this function will help the analyst to better understand
   the usage context of this function. He will then be able to navigate through the callers and look for the conditions
   in which the vulnerable function is called.

   One example provided from the SSO use case is the presence of an infinite loop in the xmltooling library,
   and more preciselly in the method decryptData of the class Decrypt, as identified by Search-Lab in frame of task T6.1.

   The question then is to verify whether this function can really been called by the deployed software or if it is just dead code to be removed.
   Answering this question is quite simple after a Callers analysis: you have just to check if some local or external callers are attached to the
   decryptData() function, either directly within the related json file or through the inspection of the caller's function callgraph
   generated for this function.

   Another case is when you want to understand the concrete data range of some input arguments, when you have for example identified
   a real case of integer overflow in the source code that can only occur when the value of the input argument exceeds or match a given value.

   Ideally, the better way to answer this question is to use the Value Analysis plugin of Frama-C.
   However this technique is not guarantied today to support fully the analysis of large-scale real-life software implemented in C++.

   #+END_SRC
** DONE Functioning and user interface [1/1]
   - [X] Describe the main functions of the plug-in and its user interface, if any.
   #+BEGIN_SRC org :tangle callers.chap6.tcs.D4.2.2.gen.org
* Functioning and user interface

   The basic idea behind the Callers plugin is to perform some kind of global static link edition of the whole software
   in order to be able to capture all the possible execution paths of the software and the different usage contexts of each function.

   Based on this information, the tool can generate different instances of function callgraphs, depending on the end-user analysis focus.
   Those callgraphs can then been further exploited to enable the verification of some global security properties on the software.

   This plugin is extensible and may be completed in the future to support other types of dependencies like:
   - data type dependencies (inheritence, composition...)
   - control-flow dependencies (behavioral analysis based on sequence diagram generation)
   - use of shared variables
   - use of vulnerable system calls (related to specific CVEs)
   
   In the future, it will also be possible to filter the function call dependencies according to a granularity level 
   (function, file, directory, libraries, application), in order to help the en-user focusing on specific parts of the software.
   
   To understand how the Callers plugin can be used by an end-user, you have first to know how it works and how it is structured,
   as explained in the Implementation section; and then how we use it on a simple example, as explained in the Example section.

   #+END_SRC
** DONE Implementation [4/4]
   Describe the internals of the plug-in
*** DONE architecture of the plugin
*** DONE big pictures [14/14]
**** DONE big picture of clang, callers and frama-C++ plugins	:all:ARCHIVE:
    #+BEGIN_SRC dot : tangle callers.frama-c++.launcher.gen.dot
digraph "Integration of Frama-C++ and Callers into the Clang/LLVM build & analysis process"
{
// title
labelloc="b"
label="Integration of Frama-C++ and Callers into the Clang/LLVM build & analysis process"

"scan-build" [ label="clang scan-build" ]
"scan-callers" [ label="STANCE scan-callers\nbash script", color=green ]
"cmake-callers" [ label="STANCE cmake-callers\nbash script", color=green ]
"scan-callers" -> "scan-build" [ label="extends", color=green ]
"scan-callers" -> "build commands" [ dir=back, color=green ]

// user build
"user build" [ label="custom build\n(autoconf, cmake..)" ]
"build commands" [ label="build commands", shape=box ]
"user build" -> "build commands"

// scan build
"scan-build" -> "user build"
"scan-build" -> "build commands" [ dir=back ]

// compilation
"object code" [ shape="box" ]

// c compilation
"c code" [ label="C code", shape="box" ]
"c compiler" [ label="C compiler\n(gcc, clang..)" ]
"build commands" -> "c compiler"
"c compiler" -> "c code" [ dir=back ]
"c compiler" -> "object code"

// c++ compilation
"cpp code" [ label="C++ code", shape="box" ]
"cpp compiler" [ label="C++ compiler\n(g++,clang++..)" ]
"build commands" -> "cpp compiler"
"cpp compiler" -> "cpp code" [ dir=back ]
"cpp compiler" -> "object code"

// cmake build
"cmake-callers" -> "cmake build" [ color=green ]
"compile_commands" [ label="compile_commands.json", shape=box ]
"cmake build" -> "cpp compiler"
"cmake build" -> "c compiler"
"cmake build" -> "compile_commands"

"cmake-callers" -> "compile_commands" [ dir=back, color=green ]

// cmake callers analysis
"cmake-callers" -> "callers frontend" [ color=green ]
"cmake-callers" -> "callers++ frontend" [ color=green ]

// clang compilation
"clang object code" [ label="Clang/LLVM object code", shape="box" ]
"llvm" [ label="LLVM" ]
//"llvm" [ label="LLVM Optimizer\n& Code Generator" ]
"llvm" -> "clang object code"

// clang compilation of C code
"clang compiler" [ label="Clang compiler" ]
"clang AST" [ shape=box ]
"scan-build" -> "clang compiler"
"clang frontend" [ label="Clang frontend" ]
"clang frontend" -> "c code" [ dir=back ]
//"clang frontend" -> "clang AST"
"clang AST" -> "clang frontend" [ dir=back ]
"clang compiler" -> "clang frontend"
"clang compiler" -> "clang AST"  [ dir=back ]
"clang compiler" -> "llvm"

// clang++ compilation of C++ code
"clang++ compiler" [ label="Clang++ compiler" ]
"scan-build" -> "clang++ compiler"
"clang++ frontend" [ label="Clang++ frontend" ]
"clang++ frontend" -> "cpp code" [ dir=back ]
"clang AST" -> "clang++ frontend" [ dir=back ]
"clang++ compiler" -> "clang++ frontend"
"clang++ compiler" -> "clang AST"  [ dir=back ]
"clang++ compiler" -> "llvm"

// clang analysis
"clang analysis results" [ shape="box" ]
"scan-build" -> "clang static analyzer"
"clang static analyzer" -> "clang checkers"
"clang checkers" -> "clang analysis results"
"clang checkers" -> "clang AST" [ dir=back ]

// clang C code analysis
"clang static analyzer" -> "clang frontend"

// clang C++ code analysis
"clang static analyzer" -> "clang++ frontend"

// callers analysis
"metadata json files" [ label="Callers metadata\njson files" ]
"metadata json files" [ shape="box", color=green ]

// callers C code analysis
"callers frontend" [ color=green, label="Callers frontend\n(C++)" ]
"callers frontend" -> "clang frontend" [ color=green ]
"callers frontend" -> "clang AST" [ dir=back, color=green ]
"callers frontend" -> "metadata json files" [ color=green ]

// callers C++ code analysis
"callers++ frontend" [ color=green, label="Callers++ frontend\n(C++)" ]
"callers++ frontend" -> "clang++ frontend" [ color=green ]
"callers++ frontend" -> "clang AST" [ dir=back, color=green ]
"callers++ frontend" -> "metadata json files" [ color=green ]

// callers backends
"analysis goals" [ label="analysis goals", shape=box, color=green ]
"user config" [ label="user analysis\nbash script", shape=box, color=green ]
"analysis goals" -> "user config" [ style=dashed, label=manual, color=green ]
"analysis goals" -> "function callgraphs" [ style=dashed, label="manual", dir=back, color=green ]
"function callgraphs" [ label="function callgraphs\n.dot files", shape=box, color=green ]
"callers backends" [ label="Callers backends\n(OCAML)", color="green" ]
"metadata json files" -> "callers backends" [ color=green ]
"metadata json files" -> "callers backends" [ dir=back, color=green ]
"user config" -> "callers backends" [ color=green ]
"callers backends" -> "function callgraphs" [ color=green ]

// frama-c++
"scan-callers" -> "frama-c" [ color=green ]
"frama-c" [ label="frama-c", color=blue ]
"framaCIRGen" -> "clang++ frontend" [ color=blue ]
"frama-c" -> "framaCIRGen" [ color=blue ]
"frama-c" -> "frama-clang" [ color=blue ]

// frama-clang analysis
//"scan-callers" -> "frama-clang"
"cmake-callers" -> "frama-clang" [ color=green ]
"frama-clang" [ label="frama-clang\n(OCAML)", color=blue ]
"framaCIRGen" [ label="framaCIRGen\n(C++)", color=blue ]
//"fir" [ label="Frama-C Intermediate\nRepresentation", shape=box ]
"fir" [ label="Frama-C IR", shape=box, color=blue ]
"cabs" [ label = "C Abstract", shape=box, color=blue ]
//"cil" [ label = "C Intermediate Language" ]
"cil" [ label = "CIL", shape=box ]

"clang AST" -> "framaCIRGen" [ color=blue ]
//"framaCIRGen" -> "fir"
"fir" -> "framaCIRGen" [ dir=back, color=blue ]
"fir" -> "frama-clang" [ color=blue ]
"frama-clang" -> "cabs" [ color=blue ]
//"cabs" -> "frama-clang" [ dir=back, color=blue ]
"cabs" -> "frama-c" [ color=blue ]
//"cabs" -> "frama-c" [ dir=back ]

// security analysis plugins
"scan-callers" -> "fc security plugins" [ color="blue" ]
"cmake-callers" -> "fc security plugins" [ color="blue" ]
"fc security plugins" [ label="STANCE frama-c\nsecurity plugins", color=blue ]
"fc security plugins" -> "VA results" [ dir=back, color=blue ]
"security analysis results" -> "fc security plugins" [ dir=back, color=blue ]

// frama-c value analysis
"VA results" [ shape=box ]
"VA" [ label="Value Analysis" ]
"VA results" [ label="VA results" ]
"VA" -> "frama-c" [ dir=back ]
//"VA" -> "VA results"
"VA results" -> "VA" [ dir=back ]
"VA" -> "cil" [ dir=back ]

// frama-c analysis
"pp C code" [ shape=box ]
"frama-c" [ label="frama-c" ]
"frama-c" -> "c code" [ dir=back ]
//"c code" -> "frama-c"
"cil" -> "frama-c"
"cil" -> "frama-c" [ dir=back ]
//"frama-c" -> "pretty-printed c code" [ label="print" ]
"frama-c" -> "pp C code" [ label="print" ]
//"frama-c" -> "c code" [ label="print" ]
}

// Local Variables:
// compile-command: "dot -Tpng callers.frama-c++.launcher.gen.dot > callers.frama-c++.launcher.gen.png"
// End:
   #+END_SRC
**** DONE use of the Callers plugin with the cmake build :analysis:callers:cmake:
    #+BEGIN_SRC dot :tangle callers.cmake.gen.dot
digraph "Use of the Callers plugin with the cmake build"
{
// title
labelloc="b"
label="Use of the Callers plugin with the cmake build"

"cmake-callers" [ label="STANCE cmake-callers\nbash script", color=blue ]

// compilation
"object code" [ shape="box" ]

// c compilation
"c code" [ label="C code", shape="box" ]
"c compiler" [ label="C compiler\n(gcc, clang..)" ]
"c compiler" -> "c code" [ dir=back ]
"c compiler" -> "object code"

// c++ compilation
"cpp code" [ label="C++ code", shape="box" ]
"cpp compiler" [ label="C++ compiler\n(g++,clang++..)" ]
"cpp compiler" -> "cpp code" [ dir=back ]
"cpp compiler" -> "object code"

// cmake build
"cmake-callers" -> "cmake build" [ color=blue ]
"compile_commands" [ label="compile_commands.json", shape=box ]
"cmake build" -> "cpp compiler"
"cmake build" -> "c compiler"
//"cmake build" -> "compile_commands"
"compile_commands" -> "cmake build" [ dir=back ]

"cmake-callers" -> "compile_commands" [ dir=back, color=blue ]

// cmake callers analysis
"cmake-callers" -> "callers frontend" [ color=blue ]
"cmake-callers" -> "callers++ frontend" [ color=blue ]

// clang compilation

// clang compilation of C code
"clang AST" [ shape=box ]
"clang frontend" [ label="Clang frontend" ]
"clang frontend" -> "c code" [ dir=back ]
"clang AST" -> "clang frontend" [ dir=back ]

// clang++ compilation of C++ code
"clang++ frontend" [ label="Clang++ frontend" ]
"clang++ frontend" -> "cpp code" [ dir=back ]
"clang AST" -> "clang++ frontend" [ dir=back ]

// callers analysis
"metadata json files" [ label="Callers metadata\njson files" ]
"metadata json files" [ shape="box", color=blue ]

// callers C code analysis
"callers frontend" [ color=blue, label="Callers frontend\n(C++)" ]
"callers frontend" -> "clang frontend" [ color=blue ]
"callers frontend" -> "clang AST" [ dir=back, color=blue ]
"callers frontend" -> "metadata json files" [ color=blue ]

// callers C++ code analysis
"callers++ frontend" [ color=blue, label="Callers++ frontend\n(C++)" ]
"callers++ frontend" [ color=blue ]
"callers++ frontend" -> "clang++ frontend" [ color=blue ]
"callers++ frontend" -> "clang AST" [ dir=back, color=blue ]
"callers++ frontend" -> "metadata json files" [ color=blue ]

// callers backends
"analysis goals" [ label="analysis goals", shape=box, color=blue ]
"user config" [ label="user analysis\nbash script", shape=box, color=blue ]
"analysis goals" -> "user config" [ style=dashed, label=manual, color=blue ]
"analysis goals" -> "function callgraphs" [ style=dashed, label="manual", dir=back, color=blue ]
"function callgraphs" [ label="function callgraphs\n.dot files", shape=box, color=blue ]
"callers backends" [ label="Callers backends\n(OCAML)", color="blue" ]
"metadata json files" -> "callers backends" [ color=blue ]
"metadata json files" -> "callers backends" [ dir=back, color=blue ]
"user config" -> "callers backends" [ color=blue ]
"callers backends" -> "function callgraphs" [ color=blue ]

// frama-c++

// frama-clang analysis

// security analysis plugins

// frama-c value analysis

// frama-c analysis

}

// Local Variables:
// compile-command: "dot -Tpng callers.cmake.gen.dot > callers.cmake.gen.png"
// End:
   #+END_SRC
**** DONE use of the Callers plugin with a custom build :analysis:callers:scan:
    #+BEGIN_SRC dot :tangle callers.scan.gen.dot
digraph "scan-callers" 
{
// title
labelloc="b"
label="Use of the Callers plugin with a custom build"

"scan-build" [ label="clang scan-build" ]
"scan-callers" [ label="STANCE scan-callers\nbash script", color=blue ]
"scan-callers" -> "scan-build" [ label="extends", color=blue ]
"scan-callers" -> "callers frontend" [ color=blue ]
"scan-callers" -> "callers++ frontend" [ color=blue ]
"scan-callers" -> "build commands" [ dir=back, color=blue ]

// user build
"user build" [ label="custom build\n(autoconf, cmake..)" ]
"build commands" [ label="build commands", shape=box ]
"user build" -> "build commands"

// scan build
"scan-build" -> "user build"
"scan-build" -> "build commands" [ dir=back ]

// compilation
"object code" [ shape="box" ]

// c compilation
"c code" [ label="C code", shape="box" ]
"c compiler" [ label="C compiler\n(gcc, clang..)" ]
"build commands" -> "c compiler"
"c compiler" -> "c code" [ dir=back ]
"c compiler" -> "object code"

// c++ compilation
"cpp code" [ label="C++ code", shape="box" ]
"cpp compiler" [ label="C++ compiler\n(g++,clang++..)" ]
"build commands" -> "cpp compiler"
"cpp compiler" -> "cpp code" [ dir=back ]
"cpp compiler" -> "object code"

// cmake build

// cmake callers analysis

// clang compilation

// clang compilation of C code
"clang AST" [ shape=box ]
"clang frontend" [ label="Clang frontend" ]
"clang frontend" -> "c code" [ dir=back ]
//"clang frontend" -> "clang AST"
"clang AST" -> "clang frontend" [ dir=back ]

// clang++ compilation of C++ code
"clang++ frontend" [ label="Clang++ frontend" ]
"clang++ frontend" -> "cpp code" [ dir=back ]
"clang AST" -> "clang++ frontend" [ dir=back ]

// clang analysis

// clang C code analysis

// clang C++ code analysis

// callers analysis
"metadata json files" [ label="Callers metadata\njson files" ]
"metadata json files" [ shape="box", color=blue ]

// callers C code analysis
"callers frontend" [ color=blue, label="Callers frontend\n(C++)" ]
"callers frontend" -> "clang frontend" [ color=blue ]
"callers frontend" -> "clang AST" [ dir=back, color=blue ]
"callers frontend" -> "metadata json files" [ color=blue ]

// callers C++ code analysis
"callers++ frontend" [ color=blue, label="Callers++ frontend\n(C++)" ]
"callers++ frontend" -> "clang++ frontend" [ color=blue ]
"callers++ frontend" -> "clang AST" [ dir=back, color=blue ]
"callers++ frontend" -> "metadata json files" [ color=blue ]

// callers backends
"analysis goals" [ label="analysis goals", shape=box, color=blue ]
"user config" [ label="user analysis\nbash script", shape=box, color=blue ]
"analysis goals" -> "user config" [ style=dashed, label=manual, color=blue ]
"analysis goals" -> "function callgraphs" [ style=dashed, label="manual", dir=back, color=blue ]
"function callgraphs" [ label="function callgraphs\n.dot files", shape=box, color=blue ]
"callers backends" [ label="Callers backends\n(OCAML)", color="blue" ]
"metadata json files" -> "callers backends" [ color=blue ]
"metadata json files" -> "callers backends" [ dir=back, color=blue ]
"user config" -> "callers backends" [ color=blue ]
"callers backends" -> "function callgraphs" [ color=blue ]

// frama-c++

// frama-clang analysis

// security analysis plugins

// frama-c value analysis

// frama-c analysis

}

// Local Variables:
// compile-command: "dot -Tpng callers.scan.gen.dot > callers.scan.gen.png"
// End:
 
   #+END_SRC
**** DONE custom build process				       :build:custom:
    #+BEGIN_SRC dot :tangle build.custom.gen.dot
digraph "custom build " 
{
// title
labelloc="b"
label="user custom build process"

// user build
"user build" [ label="custom build\n(autoconf, cmake..)" ]
"build commands" [ label="build commands", shape=box ]
"user build" -> "build commands"

// compilation
"object code" [ shape="box" ]

// c compilation
"c code" [ label="C code", shape="box" ]
"c compiler" [ label="C compiler\n(gcc, clang..)" ]
"build commands" -> "c compiler"
"c compiler" -> "c code" [ dir=back ]
"c compiler" -> "object code"

// c++ compilation
"cpp code" [ label="C++ code", shape="box" ]
"cpp compiler" [ label="C++ compiler\n(g++,clang++..)" ]
"build commands" -> "cpp compiler"
"cpp compiler" -> "cpp code" [ dir=back ]
"cpp compiler" -> "object code"
}

// Local Variables:
// compile-command: "dot -Tpng build.custom.gen.dot > build.custom.gen.png"
// End:
 
   #+END_SRC
**** DONE cmake-build process					:build:cmake:
    #+BEGIN_SRC dot :tangle build.cmake.gen.dot
digraph "cmake build" 
{
// title
labelloc="b"
label="cmake build process"

// compilation
"object code" [ shape="box" ]

// c compilation
"c code" [ label="C code", shape="box" ]
"c compiler" [ label="C compiler\n(gcc, clang..)" ]
"c compiler" -> "c code" [ dir=back ]
"c compiler" -> "object code"

// c++ compilation
"cpp code" [ label="C++ code", shape="box" ]
"cpp compiler" [ label="C++ compiler\n(g++,clang++..)" ]
"cpp compiler" -> "cpp code" [ dir=back ]
"cpp compiler" -> "object code"

// cmake build
"compile_commands" [ label="compile_commands.json", shape=box ]
"cmake build" -> "cpp compiler"
"cmake build" -> "c compiler"
"cmake build" -> "compile_commands"
}

// Local Variables:
// compile-command: "dot -Tpng build.cmake.gen.dot > build.cmake.gen.png"
// End:
 
   #+END_SRC
**** DONE clang build process					:build:clang:
    #+BEGIN_SRC dot :tangle build.clang.gen.dot
digraph "clang build" 
{
// title
labelloc="b"
label="clang build process"

"scan-build" [ label="clang scan-build" ]

"c code" [ label="C code", shape="box" ]
"cpp code" [ label="C++ code", shape="box" ]

// clang compilation
"clang object code" [ label="object code", shape="box" ]
"llvm" [ label="LLVM" ]
//"llvm" [ label="LLVM Optimizer\n& Code Generator" ]
"llvm" -> "clang object code"

// clang compilation of C code
"clang compiler" [ label="Clang compiler" ]
"clang AST" [ shape=box ]
"scan-build" -> "clang compiler"
"clang frontend" [ label="Clang frontend" ]
"clang frontend" -> "c code" [ dir=back ]
//"clang frontend" -> "clang AST"
"clang AST" -> "clang frontend" [ dir=back ]
"clang compiler" -> "clang frontend"
"clang compiler" -> "clang AST"  [ dir=back ]
"clang compiler" -> "llvm"

// clang++ compilation of C++ code
"clang++ compiler" [ label="Clang++ compiler" ]
"scan-build" -> "clang++ compiler"
"clang++ frontend" [ label="Clang++ frontend" ]
"clang++ frontend" -> "cpp code" [ dir=back ]
"clang AST" -> "clang++ frontend" [ dir=back ]
"clang++ compiler" -> "clang++ frontend"
"clang++ compiler" -> "clang AST"  [ dir=back ]
"clang++ compiler" -> "llvm"
}

// Local Variables:
// compile-command: "dot -Tpng build.clang.gen.dot > build.clang.gen.png"
// End:
 
   #+END_SRC
**** DONE clang analysis process			     :analysis:clang:
    #+BEGIN_SRC dot :tangle analysis.clang.gen.dot
digraph "clang analysis process" 
{
// title
labelloc="b"
label="clang analysis process"

"scan-build" [ label="clang scan-build" ]

// user build
"user build" [ label="custom build\n(autoconf, cmake..)" ]
"build commands" [ label="build commands", shape=box ]
"user build" -> "build commands"

// scan build
"scan-build" -> "user build"
"scan-build" -> "build commands" [ dir=back ]

// c compilation
"c code" [ label="C code", shape="box" ]

// c++ compilation
"cpp code" [ label="C++ code", shape="box" ]

// clang compilation of C code
"clang AST" [ shape=box ]
"clang frontend" [ label="Clang frontend" ]
"clang frontend" -> "c code" [ dir=back ]
//"clang frontend" -> "clang AST"
"clang AST" -> "clang frontend" [ dir=back ]

// clang++ compilation of C++ code
"clang++ frontend" [ label="Clang++ frontend" ]
"clang++ frontend" -> "cpp code" [ dir=back ]
"clang AST" -> "clang++ frontend" [ dir=back ]

// clang analysis
"analysis results" [ label="clang analysis results", shape="box" ]
"scan-build" -> "clang static analyzer"
"clang static analyzer" -> "clang checkers"
"clang checkers" -> "analysis results"
"clang checkers" -> "clang AST" [ dir=back ]

// clang C code analysis
"clang static analyzer" -> "clang frontend"

// clang C++ code analysis
"clang static analyzer" -> "clang++ frontend"

// user analysis goals & config
"user config" -> "scan-build"
"analysis goals" [ label="analysis goals", shape=box ]
"user config" [ label="user config", shape=box ]
"analysis goals" -> "user config" [ style=dashed, label=manual ]
"analysis goals" -> "analysis results" [ style=dashed, label="manual", dir=back ]
}

// Local Variables:
// compile-command: "dot -Tpng analysis.clang.gen.dot > analysis.clang.gen.png"
// End:
 
   #+END_SRC
**** DONE from frama-C++ frontend to Value analysis :analysis:frama:cpp:value:
    #+BEGIN_SRC dot :tangle analysis.frama-c++.frontend.gen.dot
digraph "Frama-C++ frontend architecture"
{
// title
labelloc="b"
label="From Frama-C++ frontend to value analysis"

// user build
"user build" [ label="custom build\n(autoconf, cmake..)" ]
"build commands" [ label="build commands", shape=box ]
"user build" -> "build commands"

// c++ compilation
"c code" [ shape=box, label="C code" ]
"cpp code" [ label="C++ code", shape=box ]
"cpp compiler" [ label="C++ compiler\n(g++,clang++..)" ]
"object code" [ label="object code", shape="box" ]
"build commands" -> "cpp compiler"
"cpp compiler" -> "cpp code" [ dir=back ]
"cpp compiler" -> "object code"

"clang AST" [ shape=box ]

"clang++ frontend" [ label="Clang++ frontend" ]
"clang++ frontend" -> "cpp code" [ dir=back ]
"clang AST" -> "clang++ frontend" [ dir=back ]

// frama-c
"frama-c" [ label="frama-c", color=blue ]
"frama-c" -> "framaCIRGen" [ color=blue ]
"framaCIRGen" -> "clang++ frontend" [ color=blue ]
"frama-c" -> "frama-clang" [ color=blue ]

// frama-clang analysis
"frama-clang" [ label="frama-clang\n(OCAML)", color=blue ]
"framaCIRGen" [ label="framaCIRGen\n(C++)", color=blue ]
//"fir" [ label="Frama-C Intermediate\nRepresentation", shape=box ]
"fir" [ label="Frama-C IR", shape=box, color=blue ]
"cabs" [ label = "C Abstract", shape=box, color=blue ]
//"cil" [ label = "C Intermediate Language" ]
"cil" [ label = "CIL", shape=box ]

"clang AST" -> "framaCIRGen" [ color=blue ]
//"framaCIRGen" -> "fir"
"fir" -> "framaCIRGen" [ dir=back, color=blue ]
"fir" -> "frama-clang" [ color=blue ]
"frama-clang" -> "cabs" [ color=blue ]
//"cabs" -> "frama-clang" [ dir=back, color=blue ]
"cabs" -> "frama-c" [ color=blue ]
//"cabs" -> "frama-c" [ dir=back ]

// frama-c value analysis
"VA results" [ shape=box ]
"VA" [ label="Value Analysis" ]
"VA results" [ label="VA results" ]
"VA" -> "frama-c" [ dir=back ]
//"VA" -> "VA results"
"VA results" -> "VA" [ dir=back ]
"VA" -> "cil" [ dir=back ]

// frama-c analysis
"pp C code" [ shape=box ]
"frama-c" [ label="frama-c" ]
"frama-c" -> "c code" [ dir=back ]
//"c code" -> "frama-c"
"cil" -> "frama-c"
"cil" -> "frama-c" [ dir=back ]
//"frama-c" -> "pretty-printed c code" [ label="print" ]
"frama-c" -> "pp C code" [ label="print" ]
//"frama-c" -> "c code" [ label="print" ]

// user analysis goals & config
"analysis goals" [ label="analysis goals", shape=box ]
"user config" [ label="user config\n(bash)", shape=box ]
"analysis goals" -> "user config" [ style=dashed, label=manual ]
"build commands" -> "user config" [ style=dashed, label=manual ]
"user config" -> "frama-c"
"analysis goals" -> "VA results" [ style=dashed, label="manual", dir=back ]
}

// Local Variables:
// compile-command: "dot -Tpng analysis.frama-c++.frontend.gen.dot > analysis.frama-c++.frontend.gen.png"
// End:
 
   #+END_SRC
**** DONE frama-c value analysis process	  :frama:c:VA:value:analysis:
    #+BEGIN_SRC dot :tangle analysis.frama-c.VA.gen.dot
digraph "Frama-C Value Analysis process"
{
// title
labelloc="b"
label="Frama-C Value Analysis process"

// frama-c value analysis
"VA results" [ shape=box ]
"VA" [ label="Value Analysis" ]
"VA results" [ label="VA results" ]
"VA" -> "frama-c" [ dir=back ]
//"VA" -> "VA results"
"VA results" -> "VA" [ dir=back ]
"VA" -> "cil" [ dir=back ]

// frama-c analysis
"c code" [ label="C code", shape="box" ]
"pp C code" [ shape=box ]
"frama-c" [ label="frama-c" ]
"frama-c" -> "c code" [ dir=back ]
//"c code" -> "frama-c"
"cil" -> "frama-c"
"cil" -> "frama-c" [ dir=back ]
//"frama-c" -> "pretty-printed c code" [ label="print" ]
"frama-c" -> "pp C code" [ label="print" ]
//"frama-c" -> "c code" [ label="print" ]

// user analysis goals & config
"analysis goals" [ label="analysis goals", shape=box ]
"user config" [ label="user config", shape=box ]
"analysis goals" -> "user config" [ style=dashed, label=manual ]
"user config" -> "frama-c"
"analysis goals" -> "VA results" [ style=dashed, label="manual", dir=back ]
}

// Local Variables:
// compile-command: "dot -Tpng analysis.frama-c.gen.dot > analysis.frama-c.gen.png"
// End:
 
   #+END_SRC
**** DONE frama-c security analysis processes	  :frama:c:VA:value:analysis:
    #+BEGIN_SRC dot :tangle analysis.frama-c.security.gen.dot
digraph "Frama-C Security Analysis processes"
{
// title
labelloc="b"
label="Frama-C Security Analysis processes"

// security analysis plugins
"security analysis results" [ label="security analysis results" color=blue shape=box ]
"fc security plugins" [ label="STANCE frama-c\nsecurity plugins", color=blue ]
"fc security plugins" -> "frama-c" [ dir=back, color=blue ]
"fc security plugins" -> "VA results" [ dir=back, color=blue ]
"security analysis results" -> "fc security plugins" [ dir=back, color=blue ]

// frama-c value analysis
"VA results" [ shape=box ]
"VA" [ label="Value Analysis" ]
"VA results" [ label="VA results" ]
"VA" -> "frama-c" [ dir=back ]
//"VA" -> "VA results"
"VA results" -> "VA" [ dir=back ]
"VA" -> "cil" [ dir=back ]

// frama-c analysis
"c code" [ label="C code", shape="box" ]
"pp C code" [ shape=box ]
"frama-c" [ label="frama-c" ]
"frama-c" -> "c code" [ dir=back ]
//"c code" -> "frama-c"
"cil" -> "frama-c"
"cil" -> "frama-c" [ dir=back ]
//"frama-c" -> "pretty-printed c code" [ label="print" ]
"frama-c" -> "pp C code" [ label="print" ]
//"frama-c" -> "c code" [ label="print" ]

// user analysis goals & config
"analysis goals" [ label="security analysis goals", shape=box ]
"user config" [ label="user config", shape=box ]
"analysis goals" -> "user config" [ style=dashed, label=manual ]
"user config" -> "frama-c" [ style=dashed, label=manual ]
"analysis goals" -> "security analysis results" [ style=dashed, label="manual", dir=back ]
"analysis goals" -> "VA results" [ style=dashed, label="manual", dir=back ]
}

// Local Variables:
// compile-command: "dot -Tpng analysis.frama-c.security.gen.dot > analysis.frama-c.security.gen.png"
// End:
 
   #+END_SRC
**** DONE Callers analysis process		   :analysis:callers:process:
     #+BEGIN_SRC dot :tangle analysis.callers.process.gen.dot
digraph "Callers analysis process"
{
// title
labelloc="b"
label="Callers analysis process"

"src code" [ label="C/C++ code", shape="box" ]

// callers analysis
"local metadata" [ label="local symbols & calls (json files)", shape="box", color=black ]
"extcallees metadata" [ label="local calls & ext callees (json files)", shape="box", color=black ]
"extcallers metadata" [ label="local & ext callers/callees (json files)", shape="box", color=black ]
"json files list" [ label="json files lists in dirs (json file)", shape="box", color=black ]
"defined symbols" [ label="defined symbols list in dirs (json file)", shape="box", color=black ]

// callers src code analysis

// callers C++ code analysis

// callers backends
"analysis goals" [ label="analysis goals", shape=box, color=black ]

//"build tool" [ label="build tool\ncmake | custom", shape=box, color=black ]
//"analysis type" [ label="analysis type\ncmake-callers|scan-callers", shape=box, color=black ]

"launch test" [ label="1) launch test (bash)", shape=oval, color=black, labelloc=l ]
"launch analysis" [ label="2) launch callers analysis\ncmake-callers | scan-callers", shape=oval, color=black ]
//"launch cmake-callers" [ label="cmake-callers analysis (bash)", shape=oval, color=black ]
//"launch scan-callers" [ label="scan-callers analysis (bash)", shape=oval, color=black ]
"list json files" [ label="3) list json files (ocaml)", shape=oval, color=black ]
"list defined symbols" [ label="4) list defined symbols (ocaml)", shape=oval, color=black ]
"add extern callees" [ label="5) add external callees (ocaml)", shape=oval, color=black ]
"add extern callers" [ label="6) add external callers (ocaml)", shape=oval, color=black ]
"json to dot" [ label="7) generate dot graphs (ocaml)", shape=oval, color=black ]
"dot to image" [ label="8) generate images (bash)", shape=oval, color=black ]

//"build tool" -> "launch test"

"launch test" -> "launch analysis"
"src code" -> "launch analysis"
"launch analysis" -> "local metadata"

//"launch analysis" -> "launch cmake-callers" [ label="build tool=cmake" ]
//"src code" -> "launch cmake-callers"
//"launch cmake-callers" -> "local metadata"

//"launch analysis" -> "launch scan-callers" [ label="build tool=custom" ]
//"src code" -> "launch scan-callers"
//"launch scan-callers" -> "local metadata"

"analysis goals" -> "launch test" [ style=dashed, label=manual, color=black ]
"analysis goals" -> "callgraphs images" [ style=dashed, label="manual", dir=back, color=black ]

subgraph "callers backends" {

label="Callers ocaml backends"

"launch test" -> "list json files"
"local metadata" -> "list json files" -> "json files list"

"launch test" -> "list defined symbols"
"json files list" -> "list defined symbols" -> "defined symbols"

"launch test" -> "add extern callees"
"local metadata" -> "add extern callees"
"defined symbols" -> "add extern callees" -> "extcallees metadata"

"launch test" -> "add extern callers"
"extcallees metadata" -> "add extern callers" -> "extcallers metadata"

"launch test" -> "json to dot"
"user config" -> "json to dot"
"extcallers metadata" -> "json to dot" -> "dot callgraphs"

"launch test" -> "dot to image"
"dot callgraphs" -> "dot to image" -> "callgraphs images"

"user config" [ label="user navigation parameters\n.dot files", shape=box, color=black ]
"dot callgraphs" [ label="function callgraphs\n.dot files", shape=box, color=black ]
"callgraphs images" [ label="function callgraphs\n.png | png files", shape=box, color=black ]

}

// "metadata json files" -> "callers backends" [ color=black ]
// "metadata json files" -> "callers backends" [ dir=back, color=black ]
// "launch script" -> "callers backends" [ color=black ]
// "callers backends" -> "dot callgraphs" [ color=black ]

}

// Local Variables:
// compile-command: "dot -Tpng analysis.callers.process.gen.dot > analysis.callers.process.gen.png"
// End:
     #+END_SRC
**** DONE preprocess dot files					    :dot2png:
     #+BEGIN_SRC bash :tangle dot2png.gen.sh
#!/bin/bash
#for d in `ls *.gen.dot example/*.dot`
for d in `ls *.dot`
do
dot -Tpng $d > $d.png
#dot -Tpng $d > $d.png 2> $d.stderr
done
     #+END_SRC
**** DONE clean work directory					      :clean:
     #+BEGIN_SRC bash :tangle clean.gen.sh
#!/bin/bash
rm -f *.gen.* *.hdm.*
#rm -f ./example/*.png
     #+END_SRC
**** DONE [#A] Envoyer ces figures à Frank Védrine comme annoncé hier :email:cea:
     DEADLINE: <2015-09-22 mar.>
*** DONE usage of other plug-ins
    none
*** DONE special requirements such as libraries or external tools, etc.
    clang/LLVM    
   #+BEGIN_SRC org :tangle callers.chap6.tcs.D4.2.2.gen.org
* Implementation
  The Callers plugin has two standalone frontend executables and several OCAML backends.

** Callers C/C++ frontends

  The Callers frontends, named callers and callers++ are used to analyze C and C++ source files respectively.
  For each source file, a json file is generated containing local symbols definitions, local function calls
  and references to the declaration of external callee functions, as mentioned in step 2 of figure TBC.

  The Callers frontends take as input the Clang AST (Abstract Syntax Tree) generated by the C/C++ parser of the Clang/LLVM frontend.

  As for Frama-C, the way to launch the Callers analysis depends on the type of build tool used to compile the source code .
  In any case, one important step is to capture the command-line arguments normally used by the build to compile each source file,
  in order for the analysis to match the usage context and the specificities of the target operating environment.
  
  In case the build tool is cmake, we can configure the build to generate the json file "compile_commands.json"
  that list the build command of each source file just by setting the macro CMAKE_EXPORT_COMPILE_COMMANDS to ON.    
  Then, we can further exploit this file as input of the cmake-callers analysis process described on figure TBC hereafter.

  # +CAPTION: Use of the Callers plugin with the cmake build
  # +NAME:   fig:cmake-callers
  [[./callers.cmake.gen.dot.png]]

  In case of another custom build process, we use the scan-callers analysis process described on figure TBC, which is a derivation of the Clang scan-build utility. 

  As documented in [scan-build], scan-build is a command line utility that enables a user to run the static analyzer over their codebase as part of performing a regular build.
  It works by overriding the CC and CXX environment variables to (hopefully) change your build to use a "fake" compiler instead of the one that would normally build the end-user project. 
  This fake compiler executes either clang or gcc (depending on the platform) to compile the code and then executes the static analyzer to analyze the code.
  It is thus also able to capture the build command of each source file, as down otherwise by the cmake build.

  # +CAPTION: Use of the Callers plugin with a custom build
  # +NAME:   fig:scan-callers
  [[./callers.scan.gen.dot.png]]

** Callers OCAML backends

  The Callers backends, implemented in OCAML, are then used to perform some kind of static link edition
  between all identified function callers and callees of the application.
  In case of function pointers, the caller function is linked to all function callee matching the same function signature.
  This enable to maximize the code coverage and to pay attention to any function call alternative, even if in a specific
  configuration only one function callee candidate is selected in the really deployed and executed software.
  
  The static link edition is composed of several steps, as presented on figure TBC:

  # +CAPTION: Callers backends
  # +NAME:   fig:callers-backends
  [[./analysis.callers.process.gen.dot.png]]

  1) we first gather the Callers frontend analysis results of all source and header files analyzed during the build process.
     
     In order to support scalability requirements, the idea is not to centralize all the collected information in a single file or database,
     but rather to facilitate the navigation between the generated json files by:
     1. generating an index file in each directory listing all the contained json files (step 3)
     2. using it to list all the symbols defined in each directory (step 4)
     Those additionnal json metadata files can also be linked the one with the other to facilitate navigation between directories.

  2) browsing the generated lists of defined symbols in each directory, we can now lookup for the definition
     of each external callee function referenced in Callers frontend's generated json files (step 5).
  
   #+END_SRC
** DONE Example [1/1]
   - [X] Illustrate the functioning of the plug-in through a small example [3/3]
     - [X] source code
     - [X] steps to analyse it
     - [X] results and interpretation of results
*** DONE samples of extracted callgraphs [4/4]
**** DONE callgraph of all function callees from the main entry point
    #+BEGIN_SRC dot :tangle main.fct.callees.gen.dot
digraph G {
  "(B)* A::get_b()";
  "int A::a()";
  "int B::b()";
  "int c()";
  "int main()";
  "printf";
  "void *malloc(size_t)";
  "void A::A()";
  "void B::B()";
  
  subgraph cluster__tools_llvm_trunk_tools_clang_tools_extra_callers_tests_test_local_callgraph_several_files_dirA_A_cpp { 
    label="A.cpp"; "void A::A()";"int A::a()";
     };
  subgraph cluster__tools_llvm_trunk_tools_clang_tools_extra_callers_tests_test_local_callgraph_several_files_dirB_B_cpp { 
    label="B.cpp"; "void B::B()";"int c()";"int B::b()";
     };
  subgraph cluster__tools_llvm_trunk_tools_clang_tools_extra_callers_tests_test_local_callgraph_several_files_test_cpp { 
    label="test.cpp"; "int main()";"(B)* A::get_b()";
     };
  subgraph cluster__usr_include_malloc_h { label="malloc.h"; "void *malloc(size_t)";
     };
  subgraph cluster__usr_include_stdio_h { label="stdio.h"; "printf";
     };
  
  "(B)* A::get_b()" -> "printf" [color="#0008FC", label="", style="solid", ];
  "int A::a()" -> "(B)* A::get_b()" [color="#0008FC", label="",
                                     style="solid", ];
  "int A::a()" -> "int B::b()" [color="#0008FC", label="", style="solid", ];
  "int A::a()" -> "printf" [color="#0008FC", label="", style="solid", ];
  "int B::b()" -> "printf" [color="#0008FC", label="", style="solid", ];
  "int c()" -> "printf" [color="#0008FC", label="", style="solid", ];
  "int main()" -> "(B)* A::get_b()" [color="#0008FC", label="",
                                     style="dashed", ];
  "int main()" -> "int A::a()" [color="#0008FC", label="", style="solid", ];
  "int main()" -> "int B::b()" [color="#0008FC", label="", style="solid", ];
  "int main()" -> "void *malloc(size_t)" [color="#0008FC", label="",
                                          style="solid", ];
  "int main()" -> "void A::A()" [color="#0008FC", label="", style="solid", ];
  "void A::A()" -> "void B::B()" [color="#0008FC", label="", style="solid", ];
  "void B::B()" -> "int c()" [color="#0008FC", label="", style="dashed", ];
  }
    #+END_SRC
**** DONE callgraph of all function callers of the c function callee
    #+BEGIN_SRC dot :tangle c.fct.callers.gen.dot
digraph G {
  "int c()";
  "int main()";
  "void A::A()";
  "void B::B()";
  
  subgraph cluster__media_sf_users_3u_tools_llvm_trunk_tools_clang_tools_extra_callers_tests_test_local_callgraph_several_files_dirA_A_cpp { 
    label="A.cpp"; "void A::A()";
     };
  subgraph cluster__media_sf_users_3u_tools_llvm_trunk_tools_clang_tools_extra_callers_tests_test_local_callgraph_several_files_test_cpp { 
    label="test.cpp"; "int main()";
     };
  subgraph cluster__tools_llvm_trunk_tools_clang_tools_extra_callers_tests_test_local_callgraph_several_files_dirB_B_cpp { 
    label="B.cpp"; "void B::B()";"int c()";
     };
  
  "int main()" -> "void A::A()" [color="#0008FC", label="", style="solid", ];
  "void A::A()" -> "void B::B()" [color="#0008FC", label="", style="solid", ];
  "void B::B()" -> "int c()" [color="#0008FC", label="", style="dashed", ];
  }
    #+END_SRC
**** DONE callgraph of all function callers of the printf system call
    #+BEGIN_SRC dot :tangle printf.fct.callers.gen.dot
digraph G {
  "(B)* A::get_b()";
  "int A::a()";
  "int B::b()";
  "int c()";
  "int main()";
  "printf";
  "void A::A()";
  "void B::B()";
  
  subgraph cluster__media_sf_users_3u_tools_llvm_trunk_tools_clang_tools_extra_callers_tests_test_local_callgraph_several_files_dirA_A_cpp { 
    label="A.cpp"; "void A::A()";"int A::a()";
     };
  subgraph cluster__media_sf_users_3u_tools_llvm_trunk_tools_clang_tools_extra_callers_tests_test_local_callgraph_several_files_dirB_B_cpp { 
    label="B.cpp"; "void B::B()";"int c()";"int B::b()";
     };
  subgraph cluster__media_sf_users_3u_tools_llvm_trunk_tools_clang_tools_extra_callers_tests_test_local_callgraph_several_files_test_cpp { 
    label="test.cpp"; "int main()";"(B)* A::get_b()";
     };
  subgraph cluster__usr_include_stdio_h { label="stdio.h"; "printf";
     };
  
  "(B)* A::get_b()" -> "printf" [color="#0008FC", label="", style="solid", ];
  "int A::a()" -> "(B)* A::get_b()" [color="#0008FC", label="",
                                     style="solid", ];
  "int A::a()" -> "int B::b()" [color="#0008FC", label="", style="solid", ];
  "int A::a()" -> "printf" [color="#0008FC", label="", style="solid", ];
  "int B::b()" -> "printf" [color="#0008FC", label="", style="solid", ];
  "int c()" -> "printf" [color="#0008FC", label="", style="solid", ];
  "int main()" -> "int A::a()" [color="#0008FC", label="", style="solid", ];
  "int main()" -> "int B::b()" [color="#0008FC", label="", style="solid", ];
  "int main()" -> "void A::A()" [color="#0008FC", label="", style="solid", ];
  "void A::A()" -> "void B::B()" [color="#0008FC", label="", style="solid", ];
  "void B::B()" -> "int c()" [color="#0008FC", label="", style="dashed", ];
  }    
    #+END_SRC
**** DONE callgraph of all function callers of the malloc system call
    #+BEGIN_SRC dot :tangle malloc.fct.callers.hdm.dot
digraph G {

"int main()";
  "void *malloc(size_t)";
  
  subgraph cluster__tools_llvm_trunk_tools_clang_tools_extra_callers_tests_test_local_callgraph_several_files_test_cpp { 
    label="test.cpp"; "int main()";
    //"(B)* A::get_b()";
     };
  subgraph cluster__usr_include_malloc_h { label="malloc.h"; "void *malloc(size_t)";
     };
     "int main()" -> "void *malloc(size_t)" [color="#0008FC", label=""];
  }    
    #+END_SRC
**** function call paths from A::A() to c()
     #+BEGIN_SRC dot :tangle A_A.c.c2c.gen.dot
digraph G {
  "int c()";
  "void A::A()";
  "void B::B()";
  "void A::A()" -> "void B::B()" [color="#0008FC", label="", style="solid", ];
  "void B::B()" -> "int c()" [color="#0008FC", label="", style="dashed", ];
  }
     #+END_SRC
**** function call paths from main() to B::b()
     #+BEGIN_SRC dot :tangle main.B_b.c2c.gen.dot
digraph G {
  "int c()";
  "int main()";
  "void A::A()";
  "void B::B()";
  
  subgraph cluster__media_sf_users_3u_tools_llvm_trunk_tools_clang_tools_extra_callers_tests_test_local_callgraph_several_files_dirA_A_cpp { 
    label="A.cpp"; "void A::A()";
     };
  subgraph cluster__media_sf_users_3u_tools_llvm_trunk_tools_clang_tools_extra_callers_tests_test_local_callgraph_several_files_test_cpp { 
    label="test.cpp"; "int main()";
     };
  subgraph cluster__tools_llvm_trunk_tools_clang_tools_extra_callers_tests_test_local_callgraph_several_files_dirB_B_cpp { 
    label="B.cpp"; "void B::B()";"int c()";
     };
  
  "int main()" -> "void A::A()" [color="#0008FC", label="", style="solid", ];
  "void A::A()" -> "void B::B()" [color="#0008FC", label="", style="solid", ];
  "void B::B()" -> "int c()" [color="#0008FC", label="", style="dashed", ];
  }
     #+END_SRC
*** documentation
    #+BEGIN_SRC org :tangle callers.chap6.tcs.D4.2.2.gen.org
* Example
  Let's suppose the example below, comprising three different C++ files.
** input source files
   Here we assume that the source files are all contained in a single directory named test_dir.
*** header files
**** test.hpp
    # +BEGIN_SRC C verbatim
#ifndef _TEST_H_
#define _TEST_H_
int main();
#endif
    # +END_SRC
**** A.hpp
    # +BEGIN_SRC C verbatim
#ifndef _A_H_
#define _A_H_
#include <stdio.h>
#include "B.hpp"

class B;

class A
{
public:
  A();
  ~A();
  int a();
  B* get_b();
private:
  B m_b;
};
#endif
    # +END_SRC
**** B.hpp
    # +BEGIN_SRC C verbatim
#ifndef _B_H_
#define _B_H_

#include <stdio.h>

class B
{
public:
  B();
  ~B();
  int b();
};
#endif
    # +END_SRC
*** source files
**** test.cpp
    # +BEGIN_SRC C verbatim
#include "A.hpp"
#include "B.hpp"
#include "test.hpp"

int main() {
  A* a = new A();
  a->a();
  B* b = a->get_b();
  b->b();
  return 0;
}

B* A::get_b() {
  printf("get_b()\n");
  return &m_b;
}
    # +END_SRC
**** A.cpp
    # +BEGIN_SRC C verbatim
#include <stdio.h>
#include "A.hpp"

A::A() {}

int A::a() {
  printf("a()\n");
  get_b()->b();
  return 0;
}
    # +END_SRC
**** B.cpp
    # +BEGIN_SRC C verbatim
#include <stdio.h>
#include "B.hpp"
#include "test.hpp"

int c() {
  printf("c()\n");
  // test des cycles
  //main();
  return 0;
}
B::B() {
  c();
}
int B::b() {
  printf("b()\n");
  return 0;
}    
    # +END_SRC
** Callers analysis steps and output json files
   Following the Callers analysis process depict on figure [fig:callers-backends], the resulting json files after static link edition are listed below:
*** step 3: list of json files generated in test directory
    This list is generated by the "list_json_files".
    # +BEGIN_SRC json verbatim
{ "dir": "test_dir",
  "files": [ "test.cpp.file.callers.gen.json",
             "B.cpp.file.callers.gen.json",
             "A.cpp.file.callers.gen.json" ]}     
    # +END_SRC
*** step 4: list of defined symbols in test directory
    It is used as input of the "list_defined_symbols" backend to generate the list of symbols defined in the current repository test_dir, as listed below:
    # +BEGIN_SRC json verbatim
{
    "directory": "test_dir",
    "path": ".",
    "depth": 0,
    "file_symbols": 
    [
	{
            "file": "test.cpp",
            "defined": [
		{ "sign": "(B)* A::get_b()", "line": 14 },
		{ "sign": "int main()", "line": 5 }
            ]
	},
	{
            "file": "A.cpp",
            "defined": [
		{ "sign": "int A::a()", "line": 7 },
		{ "sign": "void A::A()", "line": 5 }
            ]
	},
	{
            "file": "B.cpp",
            "defined": [
		{ "sign": "int B::b()", "line": 18 },
		{ "sign": "int c()", "line": 5 },
		{ "sign": "void B::B()", "line": 13 }
            ]
	}
    ]
}
    # +END_SRC
*** step 5 and 6: static syntactic-based link edition
    Each function is identified by its full symbol's signature.

    The link edition is performed in two steps:

    - step 5: performed by the add_extcallees backend
      It is used to lookup for json definitions of the external callee functions

    - step 6: performed by the add_extcallers backend
      It navigates through the list of all defined symbols and for each external callee reference, 
      it search for the pending json file where the callee function is defined in order to creates a corresponding external caller reference.

    The resulting json files listed below are now linked the one with the other and can be 

**** test.cpp.file.callers.gen.json
    Thanks to 
    # +BEGIN_SRC json verbatim
{
  "file": "test.cpp",
  "path": ".",
  "defined": [
    {
      "sign": "(B)* A::get_b()", "line": 14,
      "extcallers": [ {
          "sign": "int A::a()",
          "def": "./dirA/A.cpp:7" 
        } ], 
      "extcallees": [
        {
          "sign": "printf",
          "decl": "/usr/include/stdio.h:359"
        } ] },
    {
      "sign": "int main()", "line": 5,
      "locallees": [ "(B)* A::get_b()" ],
      "extcallees": [ {
          "sign": "int A::a()",
          "decl": "./dirA/A.hpp:15",
          "def": "./dirA/A.cpp:7" },
        {
          "sign": "int B::b()",
          "decl": "./dirB/B.hpp:12",
          "def": "./dirB/B.cpp:18" },
        {
          "sign": "void *malloc(size_t)",
          "decl": "/usr/include/malloc.h:51" },
        {
          "sign": "void A::A()",
          "decl": "./dirA/A.hpp:12",
          "def": "./dirA/A.cpp:5" 
        }
      ]
    }
  ]
}
    # +END_SRC
**** A.cpp.file.callers.gen.json
     # +BEGIN_SRC json verbatim
{
  "file": "A.cpp",
  "path": "test_dir/dirA",
  "defined": [
    {
      "sign": "int A::a()", "line": 7,
      "extcallers": [ {
          "sign": "int main()",
          "def": "test_dir/test.cpp:5"
        } ],
      "extcallees": [
        {
          "sign": "(B)* A::get_b()",
          "decl": "test_dir/dirA/A.hpp:17",
          "def": "test_dir/test.cpp:14" },
        {
          "sign": "int B::b()",
          "decl": "test_dir/dirB/B.hpp:12",
          "def": "test_dir/dirB/B.cpp:18" },
        {
          "sign": "printf",
          "decl": "/usr/include/stdio.h:359"
        } 
      ]
    },
    {
      "sign": "void A::A()", "line": 5,
      "extcallers": [
        {
          "sign": "int main()",
          "def": "test_dir/test.cpp:5"
        }
      ],
      "extcallees": [
        {
          "sign": "void B::B()",
          "decl": "test_dir/dirB/B.hpp:9",
          "def": "test_dir/dirB/B.cpp:13"
        }
      ]
    }
  ]
}     
     # +END_SRC
**** B.cpp.file.callers.gen.json
     # +BEGIN_SRC json verbatim
{
  "file": "B.cpp",
  "path": "test_dir/dirB",
  "defined": [
    {
      "sign": "int B::b()", "line": 18,
      "extcallers": [
        {
          "sign": "int A::a()",
          "def": "test_dir/dirA/A.cpp:7" },
        {
          "sign": "int main()",
          "def": "test_dir/test.cpp:5" }
      ],
      "extcallees": [
        {
          "sign": "printf",
          "decl": "/usr/include/stdio.h:359"
        } ]
    },
    {
      "sign": "int c()", "line": 5,
      "locallers": [ "void B::B()" ],
      "extcallees": [
        {
          "sign": "printf",
          "decl": "/usr/include/stdio.h:359"
        } ] },
    {
      "sign": "void B::B()", "line": 13,
      "locallees": [ "int c()" ],
      "extcallers": [
        {
          "sign": "void A::A()",
          "def": "test_dir/dirA/A.cpp:5"
        }
      ]
    }
  ]
}     
     # +END_SRC
** Analysis results and exploitation [/]
   The generated json files are used as a distributed database, gathering incrementally the analysis results of each analysis step.

   The advantage of this approach is to better support scalability by decoupling analysis steps from result presentation steps,
   taking into account that only small amount of data can raisonnably be presented to the end-user through the generated callgraphs.

   Indeed, the dot layout algrotihms for example can hardly support more than 3000 nodes in a dot graph, and the end-user more then a hundred of nodes.

   So the main challenge is to extract from the existing database the information that is really important for helping the end-user to achieve his analysis goal, and to ignore whatever else.

   This is the purpose of the "function_callers_to_dot" backend implemented in OCAML and used in step 7.

   The basic usage of this backend is to lookup for the definition of a specific function to be analyzed, taken as input,
   and then to navigate through either all its function callers or all its function callees.

   The direction to follow is provided as the first argument of the backend, as captured below.
   You can choose either the "caller", "callee" or "c2c" direction.

   The semantics of "caller" and "callee" direction values is quite straightforward.
   In case you choose the "c2c" value, it means that the generated dot graph will draw a graph of all possible function call paths between one caller function and one callee function.

   # +BEGIN_SRC text verbatim
> function_callers_to_dot.native --help
Parses function's callers and/or callees from callers's generated json files (direction=callers|callees|c2c)

  function_callers_to_dot.native DIRECTION FCT1_JSON FCT1_ID FCT1_SIGN [[OTHER ...]]

More detailed information
=== flags ===
  [-build-info]  print info about this build and exit
  [-version]     print the version of this build and exit
  [-help]        print this help text and exit
                 (alias: -?)
   # +END_SRC

*** callgraph of all function callees from the main entry point
    An example of a callee's callgraph from the main() function is presented on figure [main-callees] below.
    # +CAPTION: Callees of the main() entry point function
    # +NAME:   fig:main-callees
    [[./main.fct.callees.gen.dot.png]]
*** callgraph of all function callers of the c function callee
    Figure [fig:c-callers] presents the caller's callgraph from function c().
    # +CAPTION: Callers of function c()
    # +NAME:   fig:c-callers
    [[./c.fct.callers.gen.dot.png]]    
*** callgraph of all function callers of the printf system call
    Figure [fig:printf-callers] presents the caller's callgraph from function printf().
    #+CAPTION: Callers of function printf()
    #+NAME:   fig:printf-callers
    [[./printf.fct.callers.gen.dot.png]]    
*** callgraph of all function callers of the malloc system call
    Figure [fig:malloc-callers] presents the caller's callgraph from function malloc().
    One interest of caller's graphs is to reduce the size of the graph significantly, 
    in comparison with the callee's callgraph.
    # +CAPTION: Callers of function malloc()
    # +NAME:   fig:malloc-callers
    [[./malloc.fct.callers.hdm.dot.png]]    
*** call paths from main() function caller to "B::b()" function callee
    Figure [fig:printf-callers] show all the possible function call paths between TBC caller function and TBC callee function.
    #+CAPTION: From to ()
    #+NAME:   fig:
    [[./main.B_b.c2c.gen.dot.png]]
*** call paths from A::A() constructor to c() function callee
    Figure [fig:printf-callers] show all the possible function call paths between TBC caller function and TBC callee function.
    #+CAPTION: From to ()
    #+NAME:   fig:
    [[./A_A.c.c2c.gen.dot.png]]
    #+END_SRC
** DONE Requirements and availability [3/3]
   DEADLINE: <2015-09-24 jeu.>
   Describe
   1. [X] the requirements for compiling, installing and using the plug-in
   2. [X] the location (URL) where it can be downloaded with its documentation
   3. [X] the support (versions of Frama-C supported, plans for future support, integration into Frama-C distro, etc.)
   #+BEGIN_SRC org :tangle callers.chap6.tcs.D4.2.2.gen.org
* Requirements and availability

The Callers plugin has been prototyped and tested on a Debian Wheezy operating system v7.5.
The Callers frontends are implemented in C++ as extra tools of clang v3.7.0.
The Callers backends are developped in OCAML v4.02.2, installed through opam v1.2.2.

** Installation of LLVM, clang and the clang extra tools

To install and build clang, you have basically to clone in a working directory 
several git archives like llvm, clang, clang-tools-extra and compiler-rt:

# +BEGIN_SRC bash verbatim
cd work_dir
svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm
cd llvm/tools
svn co http://llvm.org/svn/llvm-project/cfe/trunk clang
cd ../..
cd llvm/tools/clang/tools
svn co http://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra
cd ../../../..
cd llvm/projects
svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt
# +END_SRC

Then you can compile the whole clang/LLVM source tree in RELEASE+ASSERT mode (in-tree build is not supported):

# +BEGIN_SRC bash verbatim
cd work_dir
mkdir -p build 
cd build
cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX=/tools/exec -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DCMAKE_BUILD_TYPE=Release ../trunk
make CXXFLAGS="-DKEY_WOW64_32KEY=0x0200 -D_GLIBCXX_HAVE_FENV_H"
make install
# +END_SRC

For more information, please refer to the [Clang/LLVM online documentation].

** Installation of the Callers C++ frontends

The callers and callers++ frontend are distributed in form of a standalone git archive,
named "callers.tcs.git.tgz", which is downloadable from the STANCE intranet website.

We assume here that you have succeeded in building LLVM and clang from the source archive, as described above.

To install the Callers plugin, you have first to uncompress and untar it in the source directory
dedicated to the clang extra tools, namely: work_dir/trunk/llvm/tools/clang/tools/extra.

Then you can go back to the root build directory work_dir/build and update the cmake build tree
through the commands:

# +BEGIN_SRC bash verbatim
cmake -G "Unix Makefiles" -DCMAKE_INSTALL_PREFIX=/tools/exec -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DCMAKE_BUILD_TYPE=Release ../trunk
make CXXFLAGS="-DKEY_WOW64_32KEY=0x0200 -D_GLIBCXX_HAVE_FENV_H"
make install
# +END_SRC

** Installation of the Callers OCAML backends

As for the Callers frontends, the Callers backends are distributed in a git archive
named "callgraph.tcs.git.tgz" and available in the same location.

To install opam, please refer to the online documentation [Install OPAM in 2 minutes].

Several ocaml packages are also expected to be installed on the system, like:
# +BEGIN_SRC text verbatim
atd                     1.1.2  Parser for the ATD data format description langua
atdgen                  1.6.1  Generates efficient JSON serializers, deserialize
ocamlbuild-atdgen       0.1.0  Atdgen plugin for OCamlbuild
ocamlfind               1.5.5  A library manager for OCaml
ocamlgraph              1.8.6  A generic graph library for OCaml
yojson                  1.2.1  Yojson is an optimized parsing and printing libra
# +END_SRC

To build the Callers backends, you have to uncompress and untar the archive "callgraph.tcs.git.tgz",
for example in the working directory work_dir.
Then you have simply to source the script "build_tools.sh" present in the archive
and add the path work_dir/callgraph to the PATH environment variable.

   #+END_SRC
** DONE References [1/1]
   - [X] Add some references
   #+BEGIN_SRC org :tangle callers.chap6.tcs.D4.2.2.gen.org
* References
  | Clang/LLVM online documentation | http://clang.llvm.org                            |
  | Clang static analyzer           | http://clang-analyzer.llvm.org                   |
  | opam                            | http://opam.ocamlpro.com                         |
  | Install OPAM in 2 minutes       | https://github.com/ocaml/opam/wiki/Quick_Install |
  | scan-build                      | http://clang-analyzer.llvm.org/scan-build.html   |
   #+END_SRC
* Todo list
** Support for inheritance
*** json file extension [0/2]
    0. [ ] add a *record* keyword extension (record=struct|class|union)
    1. [ ] add a *virtual* keyword extension 
    2. [ ] add an *inheritance* keyword extension
*** extended json formats in the reference example


*** C++ frontend [/]
**** step 0. _to add record definition (required for frontend, optional for backend)_
***** in file A.hpp.json
****** current json file content
       {
         "file": "A.hpp",
         "path":
         "/home/hbalp/work/src/llvm/trunk/tools/clang/tools/extra/callers/tests/test_local_callgraph_several_files/dirA",
         "records": [
	   {
            "name" : "A",
            "kind" : "class",
            "begin" : ..,
            "end" : ..
            "defined": [...]
           }
          ]
       }
****** extended json file content
       {
         "file": "A.hpp",
         "path":
         "/home/hbalp/work/src/llvm/trunk/tools/clang/tools/extra/callers/tests/test_local_callgraph_several_files/dirA",
         "defined": [...] 
       }
     
**** step 1. _to produce the virtual flag for each virtual method declaration_
       for this, completes function CallersAction::Visitor::VisitFunctionDecl(clang::FunctionDecl* Decl) {...}
       to test whether the method is virtual or not
       and if virtual, if it is a pure|defined or declared method.

       Add a flag "virtual" to be used only in case of virtual method
       "virtual": "pure | declared | defined"

       "pure": pas de définition associée dans la classe mère
	     => donc ne pas afficher cette méthode dans le graphe final

       "declared": une définition associée dans la classe mère mais localisée dans un autre fichier

       "defined": une définition associée dans la classe mère colocalisée avec sa déclaration

***** in file A.hpp.json
****** current json file content
       {
         "file": "A.hpp",
         "path":
         "/home/hbalp/work/src/llvm/trunk/tools/clang/tools/extra/callers/tests/test_local_callgraph_several_files/dirA",
         "defined": [ { "sign": "void A::~A()", "line": 13 } ]
       }
****** extended json file content
       {
         "file": "A.hpp",
         "path":
         "/home/hbalp/work/src/llvm/trunk/tools/clang/tools/extra/callers/tests/test_local_callgraph_several_files/dirA",
         "defined": [ 
            { "sign": "void A::~A()", "line": 13 } 
            { "sign": "int c()", "line": 17, "virtual": "pure" } 
          ]
       }

**** step 2. _build the inheritance graph in json format_
     complete visitInheritanceList()
***** in file A.hpp.json
****** current json file content
       {
	 "file": "D.hpp",
	 "path":
	 "/home/hbalp/work/src/llvm/trunk/tools/clang/tools/extra/callers/tests/test_local_callgraph_several_files/dirC",
	 "defined": [...]
       }
****** extended json file content
       {
	 "file": "D.hpp",
	 "path":
	 "/home/hbalp/work/src/llvm/trunk/tools/clang/tools/extra/callers/tests/test_local_callgraph_several_files/dirC",
         "inherits": [ 
            { 
              "A",
              "decl":
              "/home/hbalp/work/src/llvm/trunk/tools/clang/tools/extra/callers/tests/test_local_callgraph_several_files/dirA/A.hpp:9:23"
           }
         ]
         "defined": [...]
       }
**** step 3. _to produce or not the virtual flag at the caller site, we need to_
       move the content of method CallersAction::Visitor::VisitMemberCallExpr()
       to CallersAction::Visitor::VisitCallExpr() by using llvm::dyn_cast

***** reference example in file test.cpp.json
****** current json file content
         {
           "sign": "int A::c()",
           "decl":
             "/home/hbalp/work/src/llvm/trunk/tools/clang/tools/extra/callers/tests/test_local_callgraph_several_files/dirA/A.hpp:17",
           "def": "unlinkedExtCallee"
         }

****** extended json file content
         {
           "sign": "int A::c()",
           "decl":
             "/home/hbalp/work/src/llvm/trunk/tools/clang/tools/extra/callers/tests/test_local_callgraph_several_files/dirA/A.hpp:17",
           "def": "unlinkedExtCallee"
           "virtual":"pure|declared|defined"
         }
       	
*** OCAML backends

    1. link: visit all virtual method
       browse all callers of those virtual methods and replace each original function call 
       with a list of function call, one per derived method

    2. replaces the mother class name by the child class name in methods to link the caller and callee.

