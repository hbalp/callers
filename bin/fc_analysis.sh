#!/bin/bash
#set -x
#     Copyright (C) 2015 Thales Communication & Security
#       - All Rights Reserved
#     coded by Hugues Balp

################################################################################
#           GENERATION OF FC MAIN ENTRY POINT                                  #
################################################################################
# You need to build the input source files with debug options

# some global definitions
fc_parsed_data="fc_parsed.gen.sav"

# usage: fc_main_gen ${cmd_args}
function fc_main_gen ()
{
  cmd_args=$@
  fc_main_filename="fc_main.gen.i"
  fc_main_gen_args="fc_main.gen.args.c"
  fc_main_args_gdb_run $fc_main_gen_args $cmd_args

  cat > ${fc_main_filename} <<EOF
/* File generated by Callers's generate_fc_main.sh */
int fc_main()
{
`cat fc_main.gen.args.c`
  main(argc, argv);
}
EOF
  rm ${fc_main_gen_args}
}

function fc_main_args_gdbinit_gen ()
{
  fc_main_gen_args=$1
  gdbinit_filename=$2
  program=$3
  shift
  shift
  shift
  cmd_args=$@
  cat > ${gdbinit_filename} <<EOF
# File generated by Callers's generate_fc_main.sh

shell rm -f ${fc_main_gen_args}
set pagination off
set logging file ${fc_main_gen_args}
set logging overwrite on
set logging overwrite off

# specific loading of executable
# file ${program}

# init of some local variables
# tbc

b main

commands
set logging on
printf "  int argc=%d;\n", argc
printf "  char* argv[] = {\n"

# naive printing of the program arguments
# printf "argv[0]=%s\n", argv[0]
# printf "argv[1]=%s\n", argv[1]

# generic printing of the program arguments
# p *argv@argc

# or

# generic pretty printing the program arguments
set \$arg=0
while (\$arg < argc)
# printf "argv[%d]=%s\n", $arg, argv[\$arg++]
printf "    \"%s\"\n", argv[\$arg++]
end
printf "  };\n"
set logging off
c
end

r ${cmd_args}
quit
EOF
}

function fc_main_args_gdb_run ()
{
  fc_main_gen_args=$1
  shift
  program=$1
  cmd_args=$@
  gdbinit_filename="fc_main.gen.gdbinit"
  fc_main_args_gdbinit_gen ${fc_main_gen_args} ${gdbinit_filename} $cmd_args
  gdb ${program} -x ${gdbinit_filename}
  rm ${gdbinit_filename}
}

################################################################################
#                    PARSING OF PREPROCESSED FILES                             #
################################################################################

# This function renames the ".i" extension of gcc preprocessed src files by ".i.c"
# to enable a second preprocessing step of annotations by frama-c
function fc_rename_preproc_files ()
{
  # list preprocessed files
  fc_main_entryppoint_files=`find . -name "*.i"`
  # rename all preprocessed files
  for f in ${fc_main_entryppoint_files};
  do
    mv $f $f.c
  done
}

# This function generates a script for parsing with frama-c some preprocessed src files
function fc_parse ()
{
  #exename=$1
  fc_rename_preproc_files
  fc_filter_files_with_main_entrypoints "fc_entrypoints.gen.preproc_files"
  fc_select_preproc_files #$exename
}

# you should first call function fc_filter_files_with_main_entrypoints
# to avoid conflicts between potential main entrypoint functions reported by frama-c during parsing (see below)
function fc_select_preproc_files ()
{
  #exename=$1
  curdir=${PWD}
  preproc_files=`find ${curdir} -type f -name "*.i.c" | awk '{ print $1 " \\\" }'`
  fc_parse_prepro_files="fc_parse_preproc_files.gen.sh"
  #fc_parsed_data="fc_parsed.gen.sav"
  fc_parse_args="-pp-annot -save ${fc_parsed_data}"

  cat > ${fc_parse_prepro_files} <<EOF
#!/bin/bash
# Generated by fc_parse.sh in dir ${curdir}

frama-c -machdep x86_64 -cpp-command 'gcc -C -E -I. -DFRAMA_C' \\
${preproc_files}
${fc_parse_args}
EOF
}

################################################################################
#           FILTERING OF PREPROCESSED FILES WITH MAIN ENTRYPOINTS              #
################################################################################

# filter potential main entrypoint functions to avoid conflicts reported by frama-c during parsing
function fc_filter_files_with_main_entrypoints ()
{
  fc_entrypoints_preproc_files=$1
  curdir=${PWD}
  # list preprocessed files containing "main(" word
  fc_main_entryppoint_files=`find . -name "*.i.c" -exec egrep -l "\bmain\(" {} \;`
  # rename preprocessed files containing "main(" word
  for f in ${fc_main_entryppoint_files};
  do
    echo "WARNING: found main() entry point declaration in file $f, so we rename it into $f.main to avoid conflicts reported by frama-c during parsing" >> /dev/stderr
    mv $f $f.main
  done
  fc_renamed_main_entrypoint_files=`find . -name "*.i.c.main" | awk '{ print $1 " \\\" }' | sed -e s/\.main//g`
  cat > ${fc_entrypoints_preproc_files} <<EOF
#!/bin/bash
# Potential main entrypoint files filtered by fc_parse.sh
${fc_renamed_main_entrypoint_files}
EOF
}

################################################################################
#                    FRAMA-C VALUE ANALYSIS                                    #
################################################################################

# usage: fc_va <main_entrypoint_fct> <slevel>
# 
# if end-user main entry point:
#   Unprecise begin of analysis using the user main entry_point function
#   and without knowing the program arguments
# if fc_main entrypoint generated by function "fc_main_gen" of script "fc_analysis.sh"
#   More precise begin of analysis using the fc_main entry_point function generated by fc_main_gen
#   that captures thanks to gdb the user-defined arguments
#
function fc_va ()
{
  main=$1
  slevel=$2
  if [ -z ${slevel} ]; then
      echo "fc_va usage: fc_va <slevel>"
  else
      fc_analyzis_stdout="fc_analysis.gen.stdout"
      #fc_analyzis_stdout="/dev/null"
      fc_analyzis_stderr="fc_analysis.gen.stderr"
      fc_analyzed_data="fc_analyzed.gen.sav"
      #fc_parsed_data="fc_parsed.gen.sav"
      #fc_va_builtins_args="-val-builtin assert:Frama_C_assert"
      #fc_va_builtins_args="-val-builtin __FC_assert"
      fc_va_builtins_args=""
      time frama-c -load ${fc_parsed_data} -val -main ${main} -slevel ${slevel} ${fc_va_builtins_args} -save ${fc_analyzed_data} > ${fc_analyzis_stdout} 2> ${fc_analyzis_stderr}
      grep "warning: Neither code nor specification for function" fc_analysis.gen.stdout
  fi
}
