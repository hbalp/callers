#+AUTHOR: Hugues Balp
#+DATE: [2015-10-22 jeu.]
#+TITLE: 
#+COMMENT: OH: what is important is the analysis process
#+COMMENT: OH: show the genericity of the approach

* DONE Basic idea						 :basic:idea:
  Offer an open-source, modular and customizable tooled-up process 
  for generating abstract user-centered models from source code
* DONE Comparison with concurrent tools				:competitors:
  Concurrent tools are able either to:

  1. extract low-level models from source code, without abstraction capability
     example tools: Rhapsody UML, doxygen etc... (one to one mapping)

  2. produce some proprietary abstracted views with the help of the end-user
     (the resulting views are not importable within external modellers for further model refactoring)
     example tools: Structure101, Lattix or Understand

  But they are not able to provide both modelling extraction from source code and abstraction capability.

  This is precisely the heart of the technology we offer, which targets the capability
  to generate directly reusable and end-user focused abstract models from source code.
     
* DONE Key differentiators & innovation			 :key:differentiator:

  1. *capability to generate domain-specific models from source code*
     
  2. *agile and goal-oriented model abstraction process from source code*
     => capability to generate customizable and reusable abstract views from source code
     
  3. *robust* and *scalable* source code analysis solution for large-scale software
     => it relies on a mature and up-to-date open-source compiler: *clang/LLVM*
     
* DONE Areas of Application				       :applications:
  1. _global or focused understanding of complex software_
  2. _architecture extraction and refactoring of legacy software_
     => customer-guided architecture view extraction from source code (datamodel, functions, components, )
  3. _software security risks analysis_
     => detection of vulnerabilities and extraction of attack vectors, attack trees analysis

* DONE User benefits					      :user:benefits:
  1. *Trustable model abstractions* of complexe software implementations
     the models extracted from the source code are *correct by construction*
  2. *Get the good abstraction at the right moment*
     Help the end-users to _focus on their current engineering objectives_
     _Hide all the other details_ of the existing solution.
     At the opposite, _capability to focus on very specific details_ when needed.
  3. *Open and user-extensible* source code analysis solution
     Analysis results are stored incrementally in a json customizable open-format
* DONE Current status						     :status:
** feasibility demonstrated in form of two complementary prototypes [2/2] :feasibility:

   1. [X] the *fccm* prototype able to _generate component architecture views from C source code (2014)_

      _key feature_: 
      - support an *iterative process* with the *end-user* to generate the appropriate architecture view
      - support of *modelling abstraction* with the *notion of granularity level* and the hability to mix them
      - able to extract the *datatypes*, *interfaces* and *component definitions* from the source code
      _limitations_:
      - only able to analyse *C source code*, no support for C++
      - strongly dependent of the hard-to-configure CEA Frama-C source code analysis framework
      - generate LwCCM standard descriptors importable into MelodyCCM
      _foreseen evolution_:
      - use clang/LLVM to remove the dependency to Frama-C and add support of C++

   2. [X] the *callers* prototype able to _generate function call graphs from C++ source code (2015)_

      _key feature_:
      - incremental storage of analysis results in json files with an open and customizable format
      - static link edition of all software artifacts to enable navigation and custom dependency analysis
      - is able to follow class inheritance trees and calls to virtual functions
      - is able to provide the inputs required by the *fccm* prototype for generating component views.

      _limitations_:
      - unix-native, does not yet support windows environments
      - no back-end yet to support generation of component view from the source code

      _foreseen evolution_:
      - rewrite the *fccm* prototype as an OCAML back-end of the *callers* plugin

** language support					   :language:support:
   1. support the analysis of _C code_
   2. known evolution plan to support _C++ code_
** modelling support					  :modelling:support:
   1. generation of MelodyCCM models (in two phases, through LwCCM descriptors)
   2. possibility to customize the user-expected component-model (LwCCM, UCM, SoftIMA etc...)
* DONE Foreseen extensions					 :extensions:
  1. possibility to *control the software refactoring process* with the help of:
     - the input source code base
     - a model of the software architecture before rearchitecting
     - a model of the software architecture after rearchitecting
  2. the principle of this tool is *extensible to other languages* than C and C++

* TODO Detailed tool-up process					    :process:
** architecture view extraction process				      :steps:
** 

